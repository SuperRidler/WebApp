<html>
	<body>
		<script src="three.js"></script>
		<script type="text/javascript" src="https://raw.github.com/mrdoob/three.js/r44/examples/js/Stats.js"></script>
		<script src="jquery.min.js"></script>
		<script>
			var data = "";
			var container, stats;
			var camera, scene, renderer;
			var something = 0.01;
			var s = 0;
			var merged;
            var zoom = 0.01;
			var zoomin = true;
			var position;
			var moveSpeed = 50;
			var directionalLight, directionalLight2, ambientLight;
            
			init();
			
			function init() {
				
				container = document.createElement('div');
				document.body.appendChild(container);
				
				/* Setting up the camera (view)... probably will
				    change this from an orthographic view to something nicer. */
				camera = new THREE.OrthographicCamera(window.innerWidth/-zoom,
													 window.innerWidth/zoom,
													 window.innerHeight/zoom,
													 window.innerHeight/-zoom,
													 -10000,
													 1000000);
				camera.position.x = 6400;
				camera.position.y = 3200;
				camera.position.z = 6400;
				
				scene = new THREE.Scene();
				
				
				var merged = new THREE.Geometry();
				
				/* Draw the grid. */
				var size = 0, step = 25;
				var geometry = new THREE.Geometry();
				for (var i = -size; i <= size; i += step) {
					geometry.vertices.push(new THREE.Vector3(-size, 0, i));
					geometry.vertices.push(new THREE.Vector3(size, 0, i));
					geometry.vertices.push(new THREE.Vector3(i, 0, -size));
					geometry.vertices.push(new THREE.Vector3(i, 0, size));
				}
				var material = new THREE.LineBasicMaterial({color: 0x000000,
															opacity: 0.3});
				var grid = new THREE.Line(geometry, material);
				grid.type = THREE.LinePieces;
				scene.add(grid);

				/* Load the building data, one file at a time. */
				for (var k = 0; k < 2; k++) {
					for (var j = 0; j < 2; j++) {
						loadFile(k, j);
					}
				}
				
				/* Lights. */
				var ambientLight = new THREE.AmbientLight( Math.random() * 0x10 );
				scene.add( ambientLight );

				directionalLight = new THREE.DirectionalLight( Math.random() * 0xffffff );
				directionalLight.position.x = Math.random() - 0.5;
				directionalLight.position.y = 3200;
				directionalLight.position.z = Math.random() - 0.5;
				directionalLight.position.normalize();
				scene.add( directionalLight );

				directionalLight2 = new THREE.DirectionalLight( Math.random() * 0xffffff );
				directionalLight2.position.x = Math.random() - 0.5;
				directionalLight2.position.y = 3200
				directionalLight2.position.z = Math.random() - 0.5;
				directionalLight2.position.normalize();
				scene.add( directionalLight2 );
				
				renderer = new THREE.WebGLRenderer({antialias: true});
				renderer.setSize(window.innerWidth, window.innerHeight);
				container.appendChild(renderer.domElement);
				
				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				stats.domElement.style.zIndex = 100;
				container.appendChild( stats.domElement );
				
				position = scene.position;
				/* Start the rendering. */
				animate();
			}
			
			function animate() {
				requestAnimationFrame(animate);
				render();
				stats.update();
			}
			
			function render() {
				/* Zooming. */
				camera.left   = window.innerWidth/(-zoom-something);
				camera.right  = window.innerWidth/(zoom+something);
				camera.top    = window.innerHeight/(zoom+something);
				camera.bottom = window.innerHeight/(-zoom-something);
				/*s++;
				if (s == 10000) {
					zoomin = !zoomin;
					s = 0;
				}
                if (zoomin) {
                    something += 0.001;
                } else {
                    something -= 0.001;
                }*/
				camera.updateProjectionMatrix();
				/* Rotation. */
				/*var timer = Date.now() * 0.0001;
				camera.position.x = Math.cos(timer)*6400;
				camera.position.z = Math.sin(timer)*6400;*/
				camera.lookAt(position);
				renderer.render(scene, camera);
			}
			
			document.onkeydown = checkKey;
			function checkKey(e) {
				e = e || window.event;
				switch (e.keyCode) {
					/* Left */
					case 37:  position.z += moveSpeed;
					          position.x -= moveSpeed;
							  camera.position.z += moveSpeed;
                              camera.position.x	-= moveSpeed;
							  break;
					/* Up */
					case 38:  position.z -= moveSpeed;
					          position.x -= moveSpeed;
							  camera.position.z -= moveSpeed;
                              camera.position.x	-= moveSpeed;
							  break;
					/* Right */
					case 39:  position.z -= moveSpeed;
					          position.x += moveSpeed;
							  camera.position.z -= moveSpeed;
                              camera.position.x	+= moveSpeed;
							  break;
					/* Down */
					case 40:  position.z += moveSpeed;
					          position.x += moveSpeed;
							  camera.position.z += moveSpeed;
                              camera.position.x	+= moveSpeed;
							  break;
				}
			}
			
			/* Load the part of the grid given by x and y. */
			function loadFile(x, y) {
				var req = new XMLHttpRequest();
					req.open('GET', "/WebApp/parts/part"+x+y);
					req.onreadystatechange = function() {
						if (req.readyState == 4) {
							if (req.status == 200) {
								var lines = req.responseText.split(/\n/g);
								addBuildings(lines);
							} else {
								// (something went wrong with the request)
							}
						}
					}
					req.send();
			}
			
			function addBuildings(lines) {
				var materialB = new THREE.MeshLambertMaterial({color: 0xffffff,
															  shading: THREE.FlatShading,
															  overdraw: true});
				/* For each building, create the object and add it to the map.
                   Will be switching this to a geometry merge for speed.*/
				lines.forEach(function(line, i) {
					if (line != "\n") {
						var obj = jQuery.parseJSON(line);
						var x = obj.x;
						var y = obj.y;
						var height = obj.height;
						var buildingPts = [];
						var endPoint;
						for (var j = 0; j < x.length; j++) {
							if(j == 0) {
								endPoint = new THREE.Vector2(x[j], y[j]);
							}
							buildingPts.push(new THREE.Vector2(x[j], y[j]));
						}
						/* Remove duplicate points. This should now be handled in the file
						   splitting process. */
						for (var index = 0; index < buildingPts.length; index++) {
							for (var next = index+1; next < buildingPts.length; next++) {
								if (buildingPts[index] === buildingPts[next]) {
									buildingPts.splice(next, 1);
								}
							}
						}
						/* This end point is the start point. Required.
						   We generate it above rather than sending the same
						   thing twice. */
						buildingPts.push(endPoint);
						var buildingShape = new THREE.Shape(buildingPts);
						addShape(buildingShape, x[0], 0, y[0], height);
					}
				});
			}
			
			/* Extrudes the basic 2d shape we made from the coordinates.
			   Adds it to the map. */
			function addShape(shape, x, y, z, h) {
				var extrusionSettings = {
					size: h, height: 1, curveSegments: 3,
					bevelThickness: 1, bevelSize: 2, bevelEnabled: false,
					material: 0, extrudeMaterial: 1
				};
				var geometry = new THREE.ExtrudeGeometry( shape, extrusionSettings );
				var material = new THREE.MeshBasicMaterial( { color: 0xCC000000, side: THREE.DoubleSide, overdraw: true } );

				var mesh = new THREE.Mesh( geometry, material );
				mesh.position.set( x, y, z );
				mesh.rotation.set( 0, 45, 0 )
				scene.add( mesh );
			}
		</script>
	</body>
</html>